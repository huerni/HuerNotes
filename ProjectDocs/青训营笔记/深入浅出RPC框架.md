## RPC基本概念

RPC全称为Remote Procedure Calls，相比于本地函数调用，它可以调用远程主机上的函数，就像本地函数调用一样。  

本地函数调用需要找到函数位置，然后将数据传入函数中，并且接收结果。RPC同样需要这三个步骤，所以要实现RPC，就要解决三个问题：

1. 函数映射
2. 数据转换成字节流
3. 网络传输

### 好处

1. 单一职责，有利于分工协作和运维开发
2. 可扩展性强，资源使用率更优
3. 故障隔离，服务的整体可靠性更高

### 问题

1. 服务宕机，对方应该如何处理？
2. 在调用过程中发生网络异常，如何保证消息的可达性？
3. 请求量突增导致服务无法及时处理，有哪些应对措施？

> 要解决上述问题，需实现RPC框架

## 分层设计

### 一次RPC的完整过程

下面展示一次RPC的完整过程并介绍一些概念

![一次RPC过程](./imgs/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARPC-RPC.png)  

* IDL文件  IDL通过一种中立的方法来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以互相通信。
* 生成代码  通过编译器工具把IDL文件转换成语言对立的静态库
* 编解码  从内存中表示到字节序列的转换称为编码，反之为解码，也常叫做序列化和反序列化
* 通信协议  规范了数据在网络中的传输内容和格式。除必须的请求/响应数据外，通常还会包含额外的元数据
* 网络传输  通常基于成熟的网络库走TCP/UDP传输

### 框架设计

![分层设计](./imgs/QQ%E6%88%AA%E5%9B%BE20230609110907.png)  

### 编解码层

用户可通过thrift将IDL文件生成不同语言的CodeGen(Goland，C++，Java)  

并将数据转换为特定的格式，如：

* 语言特定的格式
> 如java.io.Serializable，可扩展性不足
* 文本格式
> JSON、XML、CSV等文本格式，具有人类可读性  IO慢
* 二进制编码
> 具备跨语言和高性能等优点，常见有Thrift的BinaryProtocol，Protobuf等
如TLV编码   [Tag][Length][Value]

### 协议层

通常有两种协议区分：  

* 特殊结束符：一个特殊字符作为每个协议单元结束的标示  
* 变长协议：以定长加不定长的部分组成，其中定长的部分需要描述不定长的内容长度  

协议构造：  

* LENGTH: 数据包大小，不包含自身
* HEADER MAGIC: 标识版本信息，协议解析时候快速校验
* SEQUENCE NUMBER: 表示数据包的seqID，可用于多路复用，单连接内递增
* HEADER SIZE: 头部长度，从第14个字节开始一直到PAYLOAD前
* PROTOCOL ID：编解码方式，有Binary和Compact两种
* TRANSFORM ID：压缩方式，如zlib和snappy
* INFO ID：传递一些定制的meta信息
* PAYLOAD：消息体

### 网络通信层

封装Sockets 操作

* 提供易用API
> 封装底层Socket API，连接管理和事件分发
* 功能
> 协议支持tcp、udp和uds等，优雅退出、异常处理等
* 性能
> 应用层buffer减少copy，高性能定时器、对象池等

## 关键指标

### 稳定性

**保障策略**  
> 注册中间件  

* 熔断：保护调用方，防止被调用的服务出现问题而影响到整个链路
> 一个服务A调用服务B，服务B的业务逻辑又调用了服务C，而这时服务C响应超时了，由于服务B依赖服务C，C超时直接导致B的业务逻辑一直等待，而这个时候服务A继续频繁地调用服务B，服务B就可能会因为堆积大量的请求而导致服务宕机，由此就导致了服务雪崩的问题。
> 1. 监控调用：熔断器会监控对服务B的调用情况，包括成功调用、失败调用和超时调用等。
> 2. 设置阈值：熔断器会设置一个阈值，用于判断服务B的调用是否正常。例如，可以设置一个失败调用的百分比阈值，当失败调用的比例超过阈值时，熔断器将触发熔断。
> 3. 熔断状态：当失败调用的比例超过阈值时，熔断器将进入熔断状态，停止向服务B发起调用，并快速返回错误响应，避免等待超时。
> 4. 熔断恢复：在熔断状态下，熔断器会定期尝试发起对服务B的调用，以检测服务是否恢复正常。如果发现服务B的调用成功率达到一定阈值，熔断器将退出熔断状态。
> 5. 半开状态：当熔断器从熔断状态退出时，会进入半开状态。在半开状态下，熔断器会允许部分请求通过，以测试服务B的可用性。如果这些请求成功，则熔断器将完全关闭，恢复正常调用；如果有请求失败，则熔断器将重新进入熔断状态。
* 限流：保护被调用方，防止大流量把服务压垮
> 当调用方发送请求过来时，服务端在执行业务逻辑之前先执行检查限流逻辑，如果发现访问量过大并且超出了限流条件，就让服务端直接降级处理或者返回给调用方一个限流异常
* 超时控制：避免浪费资源在不可用节点上
> 当下游的服务器因为某种原因响应过慢，下游服务主动停掉一些不太重要的业务，释放出服务器资源，避免浪费资源。

**性能指标**  
请求成功率

**长尾请求**  

长尾请求（Long-tail requests）是指在一个系统中，有一小部分请求的访问频率非常低，而且通常是不规律的、不可预测的。相比之下，绝大多数请求的访问频率较高，形成了常见的请求模式或者热点。  

预先设定一个阈值t3(比超时时间小)，当请求1发出去后超过t3时间都没有返回，那我们直接发起重试请求2，这样相当于有两个请求运行。然后等待请求返回，只要请求1或者请求2任意一个返回成功的结果，就可以立即结束这次请求，相比于等待超时后再发出请求，这种机制能大大减少整体延时。  

### 易用性

* 开箱即用
> 合理的默认参数选项、丰富的文档
* 周边工具
> 生成代码工具、脚手架工具

### 扩展性

分层设计，中间件扩展，代码生成工具插件扩展等

### 观测性

包含Log、Metric、Tracing工具，内置观测性服务

### 高性能

**场景**    
单机多机，单连接多连接，单/多 client/server，不同大小的请求包，不同请求类型，如pingpong，streaming等    

**目标**  
高吞吐，低延迟  

**手段**  
连接池，多路复用，高性能编解码协议，高性能网络库  

## 企业实践

RPC框架：Kitex  

网路库：Netpoll  

### 性能优化

**网络库优化**  
* 调度优化
> epoll_wait在调度上的控制，gopool重用goroutine降低运行协程数
* LinkBuffer
> 读写并行无锁，支持nocopy地流式读写，高效扩索容，NocopyBuffer池化，减少GC
* Pool
> 引入内存池和对象池，减少GC开销

**编解码优化**  

* Codegen
> 预计算并预分配内存，减少内存操作次数，包括内存分配和拷贝。inline较少函数调用次数和避免不必要的反射操作。自研Go语言实现的Thrift IDL解析和代码生成器，支持完善的Thrift IDL语法和语义检查，支持插件机制Thriftgo。
* JIT
> 使用JIT编译技术改善用户体验的同时带来更强的编解码性能，减轻用户维护生成代码的负担。基于JIT编译技术的高性能动态Thrift编解码器Frugal。

### 合并部署

微服务过微，传输和序列化开销越来越大。  

将亲和性强的服务实例尽可能调度到同一个物理机，远程RPC调用优化为本地IPC调用  


参考资料：
https://juejin.cn/course/bytetech/7142811324462923783/section/7142809631831228429