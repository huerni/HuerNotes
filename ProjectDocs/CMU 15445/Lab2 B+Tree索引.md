
Lab2要我们实现一个 B+Tree 索引的一些功能。索引类似于书本的目录，提供快速查询的功能。  

本次Lab有四个任务，前两个任务是实现B+ Tree，Task3实现索引迭代器，Task4实现索引的并发操作。  


## B+Tree

首先我们实现 B+Tree 的Page类，对应与B+树的叶子结点和中间结点。代码中已经提供了两种page的基类BPlusTreePage，我们需要填充继承基类的BPlusTreeLeafPage和BPlusTreeInternalPage。  

B+树的中间结点不存有实际数据，只存储指向孩子结点的指针。它有一个KV对数据array_用来存储数据，key是比较的关键字，value存储指向孩子结点的指针。为了方便，我们规定array_[0]不存储key，从array_[1]开始比较key(实验描述中也有提示)，中间结点存有`n`个key，`n-1`个value。  

B+树中所有的实际数据存在与叶子结点中，比如叶子结点的value存有指向真实数据地址的指针，叶子结点存有`n`个key，`n`个value。此外，B+树的叶子结点之间有链表连接，可从左边查询到最右边，所以BPlusTreeLeafPage中还有一个指针指向其右边的叶子结点。    

剩下的就是实现Page增加kv，删除kv等操作，基本都是对数组的操作。  

实现Page的基本功能后，接下来就是实现B+Tree的功能，包括索引查询，插入和删除功能。

在实现这三个功能之前，我们可以先实现一个`FindLeaf()`方法，用来找到指定key所在的叶子结点，因为不管是查询，插入和删除操作，都需要先找到其key所在的叶子结点。  

寻找叶子结点需从root_page开始查找，这时候我们需要使用Lab1实现的缓冲池管理器，指定page_id向缓冲池中`FetchPage()`，并将其强转为BPlusTreePage类。然后找到key在array_中的位置index，即`key[index]<=key<key[index+1]`(由于key是有序的，所以可以使用二分查找)，进入下面的孩子结点，循环直到找到key所在的叶子结点。其中注意BPlusTreePage和BPlusTreeLeafPage、BPlusTreeInternalPage的类型转换。  

### GetValue

GetValue的主要逻辑如下：  

1. 判断树是否为空，空树则直接返回false；
2. 找到查询key所在的叶子结点；
3. 在叶子结点中找到key对应的value，返回结果。

### Insert

Insert不仅仅是插入到叶子结点这么简单，当结点的关键字大于设置的关键字最大数目时，需要进行**分裂操作**，这也是该部分实现的重点。  

1. 判断树是否为空，如果为空，直接创建叶子结点作为根结点，将kv对插入结点，返回。  
2. 若不为空，找到key该插入的叶子结点插入kv对，插入需保证key的顺序关系。  
3. 插入后不算完，还需判断是否需要分裂。当`size == max_size`时，进行分裂。分裂时我们创建一个新的结点用来接收分裂后的数据，这里创建一个右兄弟结点，然后将后半部分数据转移过去，不仅如此，还要将右指针指向右兄弟结点。这还不算完，我们还得处理父节点。一个孩子结点分裂成两个孩子结点，父节点中必须增加一个key在两个孩子结点指针中间，该key用右孩子结点的最小key填充。  
4. 增加key后，判断`size_ == max_size`，如果不成立，返回，否则，父节点进行分裂。  
5. 

注意当根结点ID变动时，需调用`UpdateRootPageId()`方法。

